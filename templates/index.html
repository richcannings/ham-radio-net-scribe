<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ham Radio Net Scribe</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="main-content">
        <div id="net-log-section">
            <h2>Net Log</h2>
            <table id="net-log-table">
                <thead>
                    <tr>
                        <th>Call Sign</th>
                        <th>Name</th>
                        <th>Location</th>
                        <th>Type</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Log entries will be added here -->
                </tbody>
            </table>
        </div>

        <div class="container">
            <div class="panel" id="transcriptions-panel">
                <h2>Transcriptions</h2>
                <div id="transcriptions-history" class="history-box">
                    <!-- Transcriptions will be loaded here -->
                </div>
            </div>
            <div class="panel" id="gemini-outputs-panel">
                <h2>Gemini Outputs</h2>
                <div id="gemini-outputs-history" class="history-box">
                    <!-- Gemini outputs will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Store net log data client-side for now
        let netLog = [];

        async function fetchData(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Error fetching data from " + url + ":", error);
                return null;
            }
        }

        function renderNetLogTable() {
            const tableBody = document.getElementById('net-log-table').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = ''; // Clear existing rows

            netLog.forEach((entry, index) => {
                const row = tableBody.insertRow();
                
                // Callsign cell
                const callsignCell = row.insertCell();
                if (entry.callsign && entry.callsign.toLowerCase() !== "unknown") {
                    const callsignLink = document.createElement('a');
                    callsignLink.href = `https://www.qrz.com/db/${entry.callsign.toUpperCase()}`;
                    callsignLink.textContent = entry.callsign.toUpperCase();
                    callsignLink.target = "_blank";
                    callsignLink.rel = "noopener noreferrer";
                    callsignCell.appendChild(callsignLink);
                } else {
                    callsignCell.textContent = entry.callsign;
                }

                row.insertCell().textContent = entry.name;
                row.insertCell().textContent = entry.location;
                row.insertCell().textContent = entry.type;
                
                if (!entry.isCheckedIn) {
                    row.classList.add('checked-out-row');
                }

                const actionsCell = row.insertCell();
                actionsCell.classList.add('actions-cell'); // Add a class for potential styling
                
                const checkInOutButton = document.createElement('button');
                checkInOutButton.textContent = entry.isCheckedIn ? 'Check Out' : 'Check In';
                checkInOutButton.classList.add('action-button');
                checkInOutButton.onclick = () => {
                    netLog[index].isCheckedIn = !netLog[index].isCheckedIn;
                    renderNetLogTable();
                };
                actionsCell.appendChild(checkInOutButton);

                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove';
                removeButton.classList.add('action-button', 'remove-button');
                removeButton.onclick = () => {
                    netLog.splice(index, 1);
                    renderNetLogTable();
                };
                actionsCell.appendChild(removeButton);
            });
        }

        function addLogEntry(callsign, name, location, type, startCheckedIn = true) {
            if (!callsign || callsign === "unknown") {
                alert("Cannot add entry: Call sign is missing or unknown.");
                return;
            }
            netLog.push({ callsign, name, location, type, isCheckedIn: startCheckedIn }); // Use startCheckedIn parameter
            renderNetLogTable();
        }

        function updateHistory(elementId, dataArray, isGeminiOutput = false) {
            const historyDiv = document.getElementById(elementId);
            historyDiv.innerHTML = ''; // Clear previous entries
            
            dataArray.forEach(itemData => {
                const entryContainer = document.createElement('div');
                entryContainer.classList.add('history-entry-container');

                const entryTextDiv = document.createElement('div');
                entryTextDiv.classList.add('history-entry-text');
                entryTextDiv.innerHTML = ''; // Clear for constructing new content

                let parsedGeminiData = null;
                if (isGeminiOutput) {
                    try {
                        parsedGeminiData = JSON.parse(itemData);
                        let callsign = parsedGeminiData.callsign || "unknown";
                        let name = parsedGeminiData.name || "unknown";
                        let location = parsedGeminiData.location || "unknown";

                        // Create and append callsign (as link or text)
                        if (callsign && callsign.toLowerCase() !== "unknown") {
                            const callsignLink = document.createElement('a');
                            callsignLink.href = `https://www.qrz.com/db/${callsign.toUpperCase()}`;
                            callsignLink.textContent = callsign.toUpperCase();
                            callsignLink.target = "_blank";
                            callsignLink.rel = "noopener noreferrer"; // Security best practice
                            entryTextDiv.appendChild(callsignLink);
                        } else {
                            entryTextDiv.appendChild(document.createTextNode(callsign));
                        }

                        // Append name and location
                        entryTextDiv.appendChild(document.createTextNode(`, ${name} in ${location}`));
                        
                        // Append traffic information if applicable
                        if (parsedGeminiData.traffic === true) {
                            entryTextDiv.appendChild(document.createTextNode(", Traffic"));
                        }

                    } catch (e) {
                        console.warn("Gemini output is not valid JSON:", itemData, e);
                        entryTextDiv.textContent = itemData; // Fallback: Show raw string if not JSON
                        // Default for button logic if parsing fails
                        parsedGeminiData = { callsign: 'unknown', name: 'unknown', location: 'unknown', traffic: false }; 
                    }
                } else {
                    entryTextDiv.textContent = itemData;
                }
                entryContainer.appendChild(entryTextDiv);

                if (isGeminiOutput && parsedGeminiData) {
                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.classList.add('gemini-actions');

                    const types = [
                        { text: "Check In", type: "Check In", defaultCheckInState: true }, 
                        { text: "Check In/Out", type: "Check In/Out", defaultCheckInState: false },
                        { text: "Check In with Traffic", type: "Check In w/Traffic", defaultCheckInState: true }
                    ];

                    types.forEach(action => {
                        const button = document.createElement('button');
                        button.textContent = action.text;
                        button.classList.add('action-button');
                        if ((action.text === "Check In with Traffic" && parsedGeminiData.traffic === true) || 
                            (action.text === "Check In" && (parsedGeminiData.traffic === false || parsedGeminiData.traffic === "unknown"))) {
                            button.classList.add('button-green');
                        }
                        button.onclick = () => {
                            let logCallsign = parsedGeminiData.callsign || "unknown";
                            let logName = parsedGeminiData.name || "unknown";
                            let logLocation = parsedGeminiData.location || "unknown";
                            addLogEntry(logCallsign, logName, logLocation, action.type, action.defaultCheckInState);
                        };
                        buttonsDiv.appendChild(button);
                    });
                    entryContainer.appendChild(buttonsDiv);
                }
                historyDiv.appendChild(entryContainer);
            });
            historyDiv.scrollTop = historyDiv.scrollHeight;
        }

        async function refreshData() {
            const transcriptionsData = await fetchData('/get_transcriptions');
            if (transcriptionsData && transcriptionsData.transcriptions) {
                updateHistory('transcriptions-history', transcriptionsData.transcriptions, false);
            }

            const geminiOutputsData = await fetchData('/get_gemini_outputs');
            if (geminiOutputsData && geminiOutputsData.gemini_outputs) {
                updateHistory('gemini-outputs-history', geminiOutputsData.gemini_outputs, true);
            }
        }

        setInterval(refreshData, 2000);
        window.onload = () => {
            refreshData();
            renderNetLogTable(); // Initial render of the net log table
        };
    </script>
</body>
</html> 